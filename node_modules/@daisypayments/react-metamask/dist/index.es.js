import React, { Component } from 'react';
import PropTypes from 'prop-types';
import isEqual from 'lodash/isEqual';
import sortBy from 'lodash/sortBy';
import Web3 from 'web3';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    if (i % 2) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i]));
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

const NOT_INSTALLED = "MetaMask not installed";
const MISSING_PROVIDER = "Missing provider";
const LOCKED = "MetaMask is locked";
const TIMEOUT = "Timeout";

var constants = /*#__PURE__*/Object.freeze({
  NOT_INSTALLED: NOT_INSTALLED,
  MISSING_PROVIDER: MISSING_PROVIDER,
  LOCKED: LOCKED,
  TIMEOUT: TIMEOUT
});

class MetaMask {
  static async initialize({
    maxListeners
  } = {
    maxListeners: 300
  }) {
    const instance = await MetaMask.getWeb3();
    const provider = instance.currentProvider;
    provider.setMaxListeners(maxListeners);
    return new MetaMask(provider);
  }

  static hasWeb3() {
    return typeof window !== "undefined" && Boolean(window.ethereum || window.web3);
  }

  static async getWeb3() {
    if (window.ethereum) {
      // Modern dapp browsers
      window.web3 = new window.Web3(window.ethereum);
      await window.ethereum.enable();
      return window.web3;
    } else if (window.web3) {
      // Legacy dapp browsers...
      window.web3 = new window.Web3(window.web3.currentProvider);
      return window.web3;
    } else {
      throw new Error(NOT_INSTALLED);
    }
  }

  constructor(provider) {
    if (!provider) {
      throw new Error(MISSING_PROVIDER);
    }

    this.web3 = new Web3(provider);
  }

  async getWeb3() {
    return this.web3;
  }

  async getAccounts() {
    return new Promise((resolve, reject) => {
      this.web3.eth.getAccounts((err, accounts) => {
        if (err !== null) {
          reject(err);
        } else if (accounts.length === 0) {
          reject(new Error(LOCKED));
        } else {
          resolve(accounts);
        }
      });
    });
  }

}

function isEqualArray(array1, array2) {
  return isEqual(sortBy(array1), sortBy(array2));
}

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || "Component";
}

async function withTimeoutRejection(promise, timeout) {
  const sleep = new Promise((resolve, reject) => setTimeout(() => reject(new Error(TIMEOUT)), timeout));
  return Promise.race([promise, sleep]);
}
function createMetaMaskContext(initial = null) {
  const Context = React.createContext(initial);
  Context.displayName = "MetaMaskContext";
  const ContextProvider = Context.Provider;

  class MetaMaskContextProvider extends Component {
    constructor(props) {
      super(props);

      _defineProperty(this, "handleWatch", async () => {
        if (this.watcher) {
          clearTimeout(this.watcher);
        }

        if (!this.state.web3 || !this.state.accounts.length) {
          this.setState({
            awaiting: true
          });
        }

        let error = this.state.error;
        let web3 = null;
        let accounts = [];

        try {
          const isLocked = error && error.message === LOCKED;

          if (!this.metamask || isLocked) {
            this.metamask = await withTimeoutRejection(MetaMask.initialize(this.props.options), this.props.timeout);
          }

          web3 = await this.metamask.getWeb3();
          accounts = await this.metamask.getAccounts();
          error = null;
        } catch (err) {
          error = err;
        }

        if (!error) {
          this.watcher = setTimeout(this.handleWatch, this.props.delay);
        }

        const nextState = {
          web3,
          accounts,
          error,
          awaiting: false
        };
        this.setState(nextState);
        return nextState;
      });

      this.watcher = null; // timer created with `setTimeout`

      this.metamask = null;
      this.state = _objectSpread2({
        web3: null,
        accounts: [],
        awaiting: false,
        error: null
      }, props.value);
    }

    componentDidMount() {
      this.setState({
        error: MetaMask.hasWeb3() ? null : new Error(NOT_INSTALLED)
      });

      if (this.props.immediate) {
        this.handleWatch();
      }
    }

    shouldComponentUpdate(nextProps, nextState) {
      if (this.state.awaiting !== nextState.awaiting) {
        return true;
      } else if (this.state.web3 !== nextState.web3) {
        return true;
      } else if (this.state.error !== nextState.error) {
        return true;
      } else if (!isEqualArray(this.state.accounts, nextState.accounts)) {
        return true;
      } else {
        return false;
      }
    }

    componentWillUnmount() {
      if (this.watcher) {
        clearTimeout(this.watcher);
      }
    }

    // eslint-disable-next-line camelcase
    UNSAFE_componentWillReceiveProps(nextProps) {
      if (!isEqual(this.props.options, nextProps.options)) {
        this.metamask = null;
      }

      if (nextProps.immediate) {
        this.handleWatch();
      } else if (this.watcher) {
        // nextProps.immediate is false so stop timeout (if present).
        clearTimeout(this.watcher);
      }
    }

    render() {
      const _this$props = this.props,
            props = _objectWithoutProperties(_this$props, ["value"]);

      const internalValue = {
        web3: this.state.web3,
        accounts: this.state.accounts,
        awaiting: this.state.awaiting,
        error: this.state.error,
        openMetaMask: this.handleWatch
      };
      return React.createElement(ContextProvider, _extends({}, props, {
        value: internalValue
      }));
    }

  }

  _defineProperty(MetaMaskContextProvider, "propTypes", {
    /**
     * Initial value is an object shaped like { web3, accounts, error, awaiting }
     */
    value: PropTypes.any,
    // eslint-disable-line react/forbid-prop-types

    /**
     * Refresh interval for MetaMask changes.
     */
    delay: PropTypes.number,

    /**
     * Prevent memory leaks by making the PopUp timeout after some time.
     * This doesn't close the popup.
     */
    timeout: PropTypes.number,

    /**
     * Start MetaMask when loading the page.
     */
    immediate: PropTypes.bool,

    /**
     * MetaMask class initialize options
     */
    options: PropTypes.object
  });

  _defineProperty(MetaMaskContextProvider, "defaultProps", {
    value: null,
    delay: 3000,
    // retry/update every 3 seconds by default
    timeout: 20000,
    // wait for user to activate MetaMask.
    immediate: false,
    options: undefined
  });

  Context.Provider = MetaMaskContextProvider;
  return Context;
}
function withMetaMask(MetaMaskContext) {
  return function withMetaMaskContext(Comp) {
    const ComponentWithMetaMask = React.forwardRef((props, ref) => React.createElement(MetaMaskContext.Consumer, null, metamask => React.createElement(Comp, _extends({
      ref: ref,
      metamask: metamask
    }, props))));
    ComponentWithMetaMask.displayName = `withMetaMask(${getDisplayName(Comp)})`;
    return ComponentWithMetaMask;
  };
}
const PropTypesMetaMask = {
  web3: PropTypes.object,
  accounts: PropTypes.arrayOf(PropTypes.string).isRequired,
  error: PropTypes.object,
  // `Error` type
  awaiting: PropTypes.bool.isRequired,
  openMetaMask: PropTypes.func.isRequired
};
const PropTypesMetaMaskObject = PropTypes.shape(PropTypesMetaMask);
const MetaMask$1 = MetaMask;
const CONSTANTS = constants;

export { CONSTANTS, MetaMask$1 as MetaMask, PropTypesMetaMask, PropTypesMetaMaskObject, createMetaMaskContext, withMetaMask, withTimeoutRejection };
//# sourceMappingURL=index.es.js.map
